# 8. HTTP 캐시(필요이유, 적용, 메커니즘, 프록시 캐시도입개념, 캐시무효화등)

<br/>

# 목차
-  [캐시 기본 동작](#캐시-기본-동작)
    *  [캐시의 필요 이유와 적용](#캐시의-필요-이유와-적용)
    *  [검증 헤더와 조건부 요청의 필요성](#검증-헤더와-조건부-요청의-필요성)
    *  [검증 헤더와 조건부 요청이란](#검증-헤더와-조건부-요청이란)
    *  [검증 헤더와 조건부 요청의 개선](#검증-헤더와-조건부-요청의-개선)
    *  [캐시에 관련 헤더들 , 조건부 관련 헤더들](#캐시에-관련-헤더들--조건부-관련-헤더들)
-  [프록시 캐시](#프록시-캐시)
-  [캐시 무효화](#캐시-무효화)

## 캐시 기본 동작

### 캐시의 필요 이유와 적용

- 예를 들어 서버에서 사진을 받을 때 캐시가 없을 경우에는 화면을 조회할 때마다, 데이터가 변경되지 않아도 네트워크를 통해 데이터를 계속 다운로드 해야 한다. 이럴 경우 브라우저 로딩 속도가 느려지며 사용자는 기다려야 하는 상황이 발생한다.
- 이를 해결하기 위해 캐시를 사용한다. 서버는 응답시 cache-control에 캐시 유효시간을 실어 보낸다. 그렇게 되면 유효시간동안 서버의 응답을 웹브라우저 캐시에 저장해 놓는다. 브라우저가 다시 서버에 요청을할 때 캐시를 먼저 확인하여 캐시에 해당 데이터가 있다면 바로 화면에 표시할 수 있다.
- 캐시를 적용하게 되면 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.(캐시에 사진이 저장되어있는 경우 처럼). 이로써 비싼 네트워크 사용량을 줄일 수 있으며 브라우저 로딩속도 또한 향상되어 빠른 사용자 경험을 가능하게 한다.

### 검증 헤더와 조건부 요청의 필요성

- 서버로 부터 받은 사진이 브라우저 캐시에 저장되어 있다가 유효시간이 끝나게 되면 사진을 보기 위해서 다시 서버로부터 사진을 요청하고 브라우저 캐시에 저장해야 한다. 그런데 사진은 이전과 다시 받은 후에도 동일하다. 결과적으로 네트워크 자원을 낭비한것이 된다. 이를 해결하기 위해 어떻게 해야 할까? 기존 캐시에 있던 데이터가 현재 서버에 있는 데이터와 동일하고, 바뀌지 않았다는 것을 확인할 수 있는 방법이 필요하다. 그래서 사용 되는 것이 '검증 헤더'와 '조건부 요청'이다.

### 검증 헤더와 조건부 요청이란

- 서버에서 클라이언트로 응답시 데이터가 마지막에 수정된 시간(Last-Modified)을 실어 보낸다. 응답을 받은 브라우저는 캐시에 유효시간과 데이터 최종 수정일을 저장해 놓는다. 그 후 캐시가 만료되었다면 사용자가 사진을 요청할 때 캐시에 있던 사진의 최종 수정일(if-modified-since)을 서버에 보낸다. 아래 사진은 해당 요청의 예시이다.
  <img width="787" alt="사진1" src="https://github.com/KimYongJ/HTTPStudy/assets/106525587/5ac8286c-c8c6-442a-8e51-8b85e88baf19">

- 서버에서 요청사항을 확인하고 최종 수정일을 확인했을 때 변경되지 않은 데이터라면 변경되지 않았음을 알리고(304 Not Modified) HTTP Body에는 아무것도 전송하지 않는다. 아래 사진은 해당 응답의 예시이다.
    <img width="991" alt="사진2" src="https://github.com/KimYongJ/HTTPStudy/assets/106525587/fad9fa17-5a00-4a68-a9cb-6260808203cf">
- 304 Not Modified를 수신한 브라우저는, 캐시에 있는 데이터가 서버에서 변경되지 않았음을 인지하여 기존 캐시 데이터를 재사용 가능하다 판단한다. 그 후 브라우저는 만료된 캐시를 다시 사용상태로 돌린다.

- 정리
  - 캐시에서 만료된 데이터를 재사용해도 되는지 확인하기 위해 검증 헤더(Last-Modified)와 조건부 요청(if-modified-since)를 사용한다. 순서는 아래와 같다.
  - 1. 캐시 유효 시간이 초과한 경우 서버에 해당 데이터가 변경되었는지 확인을 요청한다.
  - 2. 서버의 데이터가 갱신되지 않았다면 304 Not-Modified + 헤더 메타 정보만 응답(바디X)한다.
  - 3. 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신한다.
  - 4. 클라이언트는 캐시에 저장되어 있는 데이터를 재사용할 수 있게되며 결과적으로 네트워크 다운로드가 발생하나 용량이 적은 헤더 정보만 다운로드하여 매우 실용 적인 해결책이라 할 수 있다.

### 검증 헤더와 조건부 요청의 개선

- 검증 헤더 : 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터 이고, 크게 2가지가 있다(Last-Modified와 ETag).

- 조건부 요청 헤더 : if-modified-since는 Last-Modified와 같이 사용 되며 if-none-match는 ETag와 같이 사용된다. 데이터가 변경되었으면 200 OK를 응답하고 데이터가 변경되지 않았다면 304 Not Modified를 응답한다. 이 때 304 응답은 Body가 미포함되어 있는데 200 응답에는 Body가 포함되어 있고 변경된 데이터를 모두 같이 보내준다.

- Last-Modified와 if-modified-since의 단점

  - 날짜 기반의 로직을 사용하고, 1초 미만(0.x) 단위로 캐시 조정이 불가능하다.
  - 파일의 수정 날짜로만 비교를하기 때문에 파일이 수정 된 후 원복 되어 기존과 데이터가 완전히 같더라도 날짜가 갱신되어 데이터 통신을 유발한다.
  - 실제 바뀐 데이터가 크게 중요하지 않은 경우(스페이스, 주석 같은 데이터 추가시)도 파일 수정 날짜가 변경되었다면 데이터 통신을 유발한다.

- Etag, if-none-match

  - last-modified, if-modified-since의 단점을 보완한 검증 헤더와 조건부 요청이다.
  - Etag(Entity Tag)로 캐시용 데이터에 임의의 고유한 버전 이름을 달아 두는 방법이다.
  - 데이터가 변경되면 이 고유한 버전을 변경한다. Etag만 비교하여 같으면 캐시를 재사용하고 다르다면 데이터를 서버로부터 다시 내려 받는다.
  - 아래 사진은 ETag를 이용한 방법 예시이다.
 
    <img width="907" alt="사진3" src="https://github.com/KimYongJ/HTTPStudy/assets/106525587/18b2caec-15c4-49a3-97d1-702960182c72">

  - 위 그림을 보면 서버에서 Etag 값을 클라이언트에 내려 준다. 그럼 클라이언트는 브라우저 캐시에 ETag 값을 저장한다. 그 후 캐시가 만료되었다면 서버에 요청을 보낼 때 if-none-match값에 Etag 값을 실어 보낸다. 요청을 받은 서버는 Etag 값을 확인하고, 변경되지 않았다면 304 응답을 내린다. 아래 사진은 이 내용을 그림으로 표현한 것이다.
    <img width="783" alt="사진4" src="https://github.com/KimYongJ/HTTPStudy/assets/106525587/8b178028-21c2-490e-bc50-db625049d9d5">


- 정리
  - Etag 방식은 단순히 Etag만 서버에 보내서 같으면 유지하고 다르면 데이터를 새로 받는다.
  - 캐시 제어 로직을 서버에서 완전히 관리하는 특징이 있다. 그렇기 때문에 클라이언트는 캐시 메커니즘을 알 수 없다.

### 캐시에 관련 헤더들 , 조건부 관련 헤더들

- 캐시 제어 헤더

  - Cache-Control(캐시 제어) 헤더 예시와 의미

    - Cache-Control: max-age ( 캐시 유효시간을 의미 , 초 단위 )
    - Cache-Control: no-cache ( 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용)
    - Cache-Control: no-store (데이터에 민감한 정보가 있으므로 저장하면 안된다는 의미이다.(메모리에서 사용하고 최대한 빨리 삭제 해아한다.))

  - Pragma(캐시 제어(하위 호환))

    - Pragma: no-cache ( 캐시 컨트롤의 no-cahche와 같다 )

  - Expires(캐시 유효기간(하위 호환))
    - 캐시 만료일을 정확한 날짜로 지정한다. HTTP 1.0부터 사용한다.
    - 지금은 더 유여한 Cache-Control: max-age가 권장된다.
    - Cache-Control: max-age와 함께 사용하면 Expires는 무시 된다.
    - 사용 예시 : expires: Mon, 01 Jan 1990 00:00:00 GMT

- 검증 헤더와 조건부 요청 헤더
  - 검증 헤더(Validator)
    - ETag: "v1.0" , ETag: "abcdefg123"
    - Last-Modified: Thu, 04 Jun 2020 07:19:24 GMT
  - 조건부 요청 헤더
    - If-Match , If-None-Match : ETag 값 사용
    - If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용

## 프록시 캐시

- 사용 이유 : 한국에서 미국에 있는 서버에 데이터를 요청했을 때, 0.5초의 시간이 걸린다고 가정하면 모든 브라우저들이 요청 시마다 똑같이 0.5초의 시간이 걸려 데이터를 받게 된다.그러나 가운데 프록시 캐시 서버를 두고 한국 유저들이 프록시 캐시 서버를 통해 요청을 하도록하면 첫번 째 사람만 0.5초가 걸리고, 나머지 사람들은 프록시 캐시 서버에 저장된 것을 단순히 가져다 쓸 수 있기 때문에 데이터를 받기 까지 시간이 단축 된다. 아래는 해당 내용의 예시이다.
  - 프록시 캐시 도입 전
    <img width="890" alt="사진5" src="https://github.com/KimYongJ/HTTPStudy/assets/106525587/e9991a92-2b90-4691-928b-afa886a48b63">
  - 프록시 캐시 도입 후
    <img width="965" alt="사진6" src="https://github.com/KimYongJ/HTTPStudy/assets/106525587/1760d46d-f928-4e6a-bfc6-bea0aab6f6a1">
  - public 캐시 : 프록시 캐시 서버를 퍼블릭 캐시라 명명
  - private 캐시 : 로컬 브라우저 캐시를 프라이빗 캐시로 명명
- 캐시 지시어(directives)
  - Cache-Control: public
    - 응답이 public 캐시에 저장되어도 된다는 뜻이다.
  - Cache-Control: private
    - 응답이 해당 사용자만을 위한 것임을 의미, private 캐시에 저장해야 한다.(기본값임)
  - Cache-Control: s-maxage
    - 프록시 캐시에만 적용되는 Max-Age이다.
  - Age: 60 (HTTP 헤더에서 사용)
    - Origin 서버에서 응답 후 프록시 캐시 서버내에서 머문 시간(초단위)

## 캐시 무효화

- Cache-Control에 확실한 캐시 무효화를 선언 할 수 있는 방법 소개이다. 캐시는 사용자가 정의하지 않아도 웹브라우저가 Get 요청등일 경우 임의로 캐시에 저장할 때가 있다. 이를 막는 방법을 캐시 무효화라 명명한다. 아래는 모든 캐시를 무효화 하기 위한 헤더 명령어 이다.
  - Cache-Control: no-cache, no-store, must-revalidate // 3개를 다 넣어 주어야 한다.
  - Pragma: no-cache (HTTP 1.0 밑 버전에서도 캐시 요청이 올 수있어서 이를 방지하기 위한 것)
    - 설명
      - 위와 같이 Cache-Control에 3가지를 넣고, Pragma헤더에도 no-cache를 넣어 주면 HTTP 1.0하위 버전도 캐시를 무효화할 수 있다.
      - no-cache : 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용한다는 의미이다. 아래 사진은 no-cache를 받은 프록시 캐시와 원 서버의 동작 방식이다.
        <img width="985" alt="사진7" src="https://github.com/KimYongJ/HTTPStudy/assets/106525587/017e3641-cbd7-497d-ae72-e2fcbc404ee5">

        - 위 처럼 프록시 캐시에서 원 서버에 접근이 가능하면 문제가 없겠지만 아래 사진 처럼 응답이 불가능한 경우도 있다. 이럴 경우 프록시 캐시 서버의 정책에 따라 응답은 다르다.
          <img width="932" alt="사진8" src="https://github.com/KimYongJ/HTTPStudy/assets/106525587/f5dcfbb6-fb64-4d4c-a15b-e8fd13f79d8f">

      - no-store : 데이터에 민감한 정보가 있으므로 저장하면 안됨을 의미(메모리에서 사용 후 최대한 빨리 삭제)
      - must-revalidate : 캐시 만료 후 최초 조회시 원 서버에 검증 해야하고 원 서버 접근 실패시 반드시 오류가 발생해야함을 의미한다(504 Gateway Timeout). 아래는 must-revalidate의 동작 예시이다.
        <img width="917" alt="사진9" src="https://github.com/KimYongJ/HTTPStudy/assets/106525587/3acdd6c9-96fb-41d6-8b00-6f2e5cfc2f80">

